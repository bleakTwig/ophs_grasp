#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <stdlib.h>
#include <time.h>
#include <cmath>

/* TODO: write a description for each function in a standard C way.
 * TODO: the tour construction algorithm has no encouragement to move around the
 *          solution space, causing many solutions to be curled up in a small
 *          area. Different construction algorithms could be proposed that favor
 *          exploration of the solution space.
 * TODO: tours should be a struct themselves, with a trips vector (or dynamic
 *          array) and a score.
 * TODO: trips should only contain a vertex's index, not the entire struct.
 * TODO: use shorter names, like v for the vertices array and t for the tours
 *          array, this will lead to less verbose and more readable code in the
 *          long run.
 * TODO: test separating the hotel selection to the poi selection in two diffe-
 *          rent for loops. It might work better. For the hotel selection, try
 *          maximizing the usable distance and the trip potential score (or ho-
 *          tel score if I'm lazy).
 * TODO: upgrade the file output so that it also shows the total score collected
 *          in each individual trip as well as for the whole tour.
 * TODO: separate this main.cpp into different files connected through .hpp
 *          and write a make to compile it all.
 */
struct Vertex {
    int index;
    double x;
    double y;
    double score;
    double tempScore; // used for computing each trip
    bool operator < (const Vertex& ver) const {
        return (tempScore < ver.tempScore);
    }
    bool operator > (const Vertex& ver) const {
        return (tempScore > ver.tempScore);
    }
};
struct Trip {
    struct Vertex start;
    struct Vertex end;
    std::vector<struct Vertex> poiList;
    // std::vector<unsigned int> poiList;
    double totalLength;
    double remainingLength;
    double score;
    /* double score() {
     *  TODO: calculate score based on each vertex in poiList instead of manua-
     *          lly updating it.
    }*/
};
double d(struct Vertex a, struct Vertex b, double **distancesMatrix) {
    if (distancesMatrix[a.index][b.index] == -1.0)
        distancesMatrix[a.index][b.index] =
            sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));
    return distancesMatrix[a.index][b.index];
}
void fillMatrix(unsigned int hotelsSize, unsigned int poisSize,
                double **distancesMatrix) {
    /*
     * fills the distance matrix with -1.0.
     */
    for (unsigned int i = 0; i < hotelsSize + poisSize; ++i) {
        for (unsigned int j = 0; j < hotelsSize + poisSize; ++j) {
            if (i == j) distancesMatrix[i][j] = 0.0;
            else distancesMatrix[i][j] = -1.0;
        }
    }
    return;
}
void calculateHotelScore(unsigned int hotelsSize, unsigned int poisSize,
                         struct Vertex *v, double **distancesMatrix) {
    /*
     * assigns a score to each hotel based on the scores of the pois around it
     * divided by the distance to each, updating the vertices array. This
     * assignation is static, meaning that it's done only once in the
     * algorithm's execution.
     * TODO: The ratio of importance for a vertex's score vs distance to it
     *          should be handled by a parameter.
     * TODO: Implement the distance of each poi to the trip line instead of the
     *          distance straight to the hotel.
     */
    for (unsigned int i = 2; i < hotelsSize; ++i) { // go through hotels (0 and 1 are required)
        for (unsigned int j = hotelsSize; j < hotelsSize + poisSize; ++j) { // go through pois
            if (d(v[i], v[j], distancesMatrix) <= 1.0)
                v[i].score += v[j].score;
            else
                v[i].score += v[j].score / d(v[i], v[j], distancesMatrix);
        }
    }
    return;
}
void tourGreedyRandomizedConstruction(
        unsigned int tripsSize, struct Trip *tour,
        unsigned int hotelsSize/*, unsigned int poisSize*/, struct Vertex *v,
        double **distancesMatrix,
        unsigned int RCLSize) {
    /*
     * places the starting and ending hotels in the first and last trips respectively
     * creates an unpicked hotels std::vector<struct Vertex>
     * for each trip given by tripsSize:
     *  * sorts the list by score divided by the distances
     *  * picks from this list in a greedy randomized fashion
     *  * sets this hotel as the end of the current trip and as the start of the next trip
     */
    tour[0].start = v[0];
    tour[tripsSize - 1].end = v[1];
    std::vector<struct Vertex> candidateHotels;
    candidateHotels.reserve(hotelsSize - 2);
    for (unsigned int i = 2; i < hotelsSize; ++i)
        candidateHotels.push_back(v[i]);
    for (unsigned int i = 0; i < tripsSize - 1; ++i) {
        // assigns score divided by distance to each hotel
        // TODO: this can be improved by instead using the distance from each
        //       poi to the line created between two hotels as the score for
        //       each. This also eliminates the necessity for the tempScore
        //       variable.

        // calculate temporary score
        for (unsigned int j = 0; j < candidateHotels.size(); ++j)
            candidateHotels[j].tempScore = candidateHotels[i].score /
                (d(v[0], v[j+2], distancesMatrix) +
                 d(v[j+2], v[1], distancesMatrix));
        if (RCLSize > candidateHotels.size())
            RCLSize = candidateHotels.size() - 1;
        // sorts hotels by this temporary score
        std::sort(candidateHotels.rbegin(), candidateHotels.rend());

        // pick one hotel from the RCL
        unsigned int choice;
        if (RCLSize > 0) choice = rand() % RCLSize;
        else             choice = 0;

        tour[i].end = candidateHotels[choice]; // TODO: reference instead of copy
        tour[i + 1].start = tour[i].end;

        // remove the chosen hotel from the RCL
        candidateHotels.erase(candidateHotels.begin() + choice);
    }
    // update the remainingLength from each trip
    for (unsigned int i = 0; i < tripsSize; ++i)
        tour[i].remainingLength = tour[i].totalLength -
            d(v[tour[i].start.index], v[tour[i].end.index], distancesMatrix);
    // TODO: check if one remainingLength is negative and repair or scrap the solution
    return;
}
// TODO: a function that checks if a tour is unfeasible and drops or repairs it
void tourLocalSearch(
        unsigned int tripsSize, struct Trip *tour,
        unsigned int hotelsSize/* unsigned int poisSize*/, struct Vertex *v,
        double **distancesMatrix) {
    return;
}
void tripGreedyRandomizedConstruction(
        unsigned int tripsSize, struct Trip *tour,
        unsigned int hotelsSize, unsigned int poisSize, struct Vertex *v,
        double **distancesMatrix,
        unsigned int RCLSize) {
    std::vector<struct Vertex> candidatePois;

    candidatePois.reserve(poisSize);
    for (unsigned int i = 0; i < poisSize; ++i)
        candidatePois.push_back(v[hotelsSize + i]);
    for (unsigned int i = 0; i < tripsSize; ++i) {
        bool first = true;
        while(tour[i].remainingLength >= 0.0) {
            if (RCLSize > candidatePois.size())
                RCLSize = candidatePois.size() - 1;

            // update the candidate list scores
            for (unsigned int j = 0; j < candidatePois.size(); ++j) {
                if (first)
                    candidatePois[j].tempScore = candidatePois[j].score /
                    (d(tour[i].start, candidatePois[j], distancesMatrix) +
                     d(candidatePois[j], tour[i].end, distancesMatrix));
                else
                    candidatePois[j].tempScore = candidatePois[j].score /
                    (d(tour[i].poiList.back(), candidatePois[j], distancesMatrix) +
                    d(candidatePois[j], tour[i].end, distancesMatrix));
            }

            // sort pois by this temporary score
            std::sort(candidatePois.rbegin(), candidatePois.rend());

            // pick one poi from the RCL
            int choice;
            if (RCLSize > 0) choice = rand() % RCLSize;
            else             choice = 0;
            tour[i].poiList.push_back(candidatePois[choice]); // TODO: reference instead of copy
            if (first) {
                tour[i].remainingLength = tour[i].remainingLength
                    + d(tour[i].start, tour[i].end, distancesMatrix)
                    - d(tour[i].start, tour[i].poiList.back(), distancesMatrix)
                    - d(tour[i].poiList.back(), tour[i].end, distancesMatrix);
                tour[i].score = tour[i].poiList.back().score;
            }
            else {
                tour[i].remainingLength = tour[i].remainingLength
                    + d(tour[i].poiList.rbegin()[1], tour[i].end, distancesMatrix)
                    - d(tour[i].poiList.rbegin()[1], tour[i].poiList.back(), distancesMatrix)
                    - d(tour[i].poiList.back(), tour[i].end, distancesMatrix);
                tour[i].score += tour[i].poiList.back().score;
            }
            // remove the chosen poi from the RCL
            candidatePois.erase(candidatePois.begin() + choice);
            if (tour[i].remainingLength < 0.0) {
                if (first) {
                    candidatePois.push_back(tour[i].poiList.back());
                    tour[i].remainingLength -=
                        d(tour[i].poiList.back(), tour[i].end, distancesMatrix);
                    tour[i].remainingLength +=
                        d(tour[i].start, tour[i].poiList.back(), distancesMatrix);
                    tour[i].remainingLength +=
                        d(tour[i].poiList.back(), tour[i].end, distancesMatrix);
                    tour[i].score -= tour[i].poiList.back().score;
                    tour[i].poiList.pop_back();
                    break;
                }
                else {
                    // DEBUG: UNDEFINED BEHAVIOUS IN THE FOLLOWING CODE:
                    // add the last POI added back to candidates and remove it from the trip
                    // it is worth noting that this is far from optimal, but it shouldn't
                    //     really bother much since there is a local search phase afterwards
                    candidatePois.push_back(tour[i].poiList.back());
                    tour[i].remainingLength -=
                        d(tour[i].poiList.rbegin()[1], tour[i].end, distancesMatrix);
                    tour[i].remainingLength +=
                        d(tour[i].poiList.rbegin()[1], tour[i].poiList.back(), distancesMatrix);
                    tour[i].remainingLength +=
                        d(tour[i].poiList.back(), tour[i].end, distancesMatrix);
                    tour[i].score -= tour[i].poiList.back().score;
                    tour[i].poiList.pop_back();
                    break;
                }
            }
            first = false;
        }
    }
    return;
}
void tripLocalSearch(unsigned int tripsSize, struct Trip *tour,
        unsigned int hotelsSize, unsigned int poisSize, struct Vertex *v,
        double **distancesMatrix, unsigned int maxIter) {
    // TODO: see about going through N iterations without changes instead of
    //          using maxIter.
    for (unsigned int iter = 0; iter < maxIter; ++iter) {
        /* TODO: insert: go through all the pois and see which one can be added
         *          with the most added score divided by distance.
         * TODO: I'm gonna need the candidateList for this, otherwise I'll need
         *          to go through each poi in the trip again lot of times, WHICH
         *          IS NOT THAT INNEFICIENT TBH.
         */

    }
    // TODO: move-best
    // TODO: two-opt
    // TODO: swap-trips
    // TODO: extract-insert
    // TODO: extract2-insert
    // TODO: extract5-insert
    // TODO: extract-move-insert
    // TODO: replacement
    return;
}
void printVariables(unsigned int tripsSize, double *tripsLength,
                    unsigned int hotelsSize, unsigned int poisSize, struct Vertex *vertices) {
    /*
     * prints all the variables obtained from the read file for debugging purposes.
    */
    printf("\n----Trips length:----\n");
    for (unsigned int i = 0; i < tripsSize; ++i)
        printf("index%u: %.2f\n", i, tripsLength[i]);
    printf("\n-------Hotels:-------\n");
    for (unsigned int i = 0; i < hotelsSize; ++i)
        printf("hotel%d: %.2f %.2f - %.2f\n", i, vertices[i].x, vertices[i].y, vertices[i].score);
    printf("\n--------POIs:--------\n");
    for (unsigned int i = hotelsSize; i < hotelsSize + poisSize; ++i)
        printf("poi%d: %.2f %.2f - %.2f\n", i, vertices[i].x, vertices[i].y, vertices[i].score);
    return;
}
void printMatrix(unsigned int hotelsSize, unsigned int poisSize, double **distancesMatrix) {
    /*
     * prints all the values in the distances matrix for debugging purposes.
     */
    for (unsigned int i = 0; i < hotelsSize + poisSize; ++i) {
        for (unsigned int j = 0; j < hotelsSize + poisSize; ++j) {
            if (distancesMatrix[i][j] < 10.0)
                printf(" %.2f ", distancesMatrix[i][j]);
            else
                printf("%.2f ", distancesMatrix[i][j]);
        }
        printf("\n");
    }
    return;
}
void printHotelScores(unsigned int hotelsSize, struct Vertex *vertices) {
    for (unsigned int i = 0; i < hotelsSize; ++i)
        printf("%d: (%.2f,%.2f) %.2f\n",
               i, vertices[i].x, vertices[i].y, vertices[i].score);
    return;
}
void printTourHotels(unsigned int tripsSize, struct Trip *tour,
                     double **distancesMatrix) {
    /*
     * TODO: this is the variable we are optimizing in the construction of each
     *       tour. When analyzing each solution this is what we need to compare
     *       between solutions, and when tuning the RCLSize parameter this is
     *       one of the best comparing factors before actually building each
     *       trip.
     */
    double usableDistance = 0;
    for (unsigned int i = 0; i < tripsSize; ++i) {
        printf("%d(%.2f,%.2f) - %d(%.2f,%.2f), %.2f - %.2f = %.2f\n",
            tour[i].start.index, tour[i].start.x, tour[i].start.y,
            tour[i].end.index, tour[i].end.x, tour[i].end.y,
            tour[i].totalLength,
            distancesMatrix[tour[i].start.index][tour[i].end.index],
            tour[i].remainingLength);
        usableDistance += tour[i].remainingLength;
    }
    printf("usable distance: %.2f\n", usableDistance);
    return;
}
void printTours(unsigned int tripsSize, struct Trip *tour) {
    double totalScore = 0.0;
    for (unsigned int i = 0; i < tripsSize; ++i) {
        totalScore += tour[i].score;
        printf("-------------------------------------------\n");
        printf("Trip %u\nscore: %.2f\nremLength: %.2f\n",
               i, tour[i].score, tour[i].remainingLength);
        printf("- hotel%d: (%.2f, %.2f)\n",
               tour[i].start.index, tour[i].start.x, tour[i].start.y);
        for (unsigned int j = 0; j < tour[i].poiList.size(); ++j)
            printf("  - poi%d: (%.2f, %.2f) - %.2f\n",
                   tour[i].poiList[j].index,
                   tour[i].poiList[j].x,
                   tour[i].poiList[j].y,
                   tour[i].poiList[j].score);
        printf("- hotel%d: (%.2f, %.2f)\n",
               tour[i].end.index, tour[i].end.x, tour[i].end.y);
    }
    printf("total score: %.2f\n", totalScore);
    return;
}
void writeTours(unsigned int tripsSize, struct Trip *tour, std::string fileName) {
    std::ofstream out;
    out.open (fileName, std::ofstream::out | std::ofstream::trunc);
    for (unsigned int i = 0; i < tripsSize; ++i) {
        out << tour[i].start.index << " "; // write trip's start hotel
        for (unsigned int j = 0; j < tour[i].poiList.size(); ++j)
            out << tour[i].poiList[j].index << " "; // write trip's pois
        out << tour[i].end.index << "\n"; // write trip's end hotel
    }
    out.close();
    return;
}
int main(int argc, char* argv[]) {
    /* TODO: argument handling
     *  fileName with a default file chosen if none is given
     *  number of iterations with a default given by average time per iteration
     *  a flag for choosing between a random seed or a given one
     *  amount of iterations to be run
     *  HotelRCLSize with a default of 3
     *  PoiRCLSize with a default of 3
     *  Debug flag with a default of false, with 1 meaning normal and 2 meaning verbose
     */
    unsigned int iterNumber = 1000;

    unsigned int HotelRCLSize = 3;
    unsigned int PoiRCLSize = 3;
    unsigned int debug = 0;

    srand(time(NULL)); // TODO: a flag should handle this

    std::string fileName;
    if      (argc == 2) fileName = argv[1];
    else if (argc == 3) {
        fileName = argv[1];
        fileName += " ";
        fileName += argv[2];
    }
    else {
        printf("no instance given. Exiting...\n");
        return 1;
    }

    if (!debug) {
        std::cout << "Running on " << fileName << "..." << std::endl;
    }

    // variables used
    unsigned int tripsSize;
    double *tripsLength;
    unsigned int hotelsSize;
    unsigned int poisSize;
    struct Vertex *vertices;
    // TODO: unsigned int unusedVertices MAYBE NOT REALLY NECESSARY;

// === FILE READING ============================================================
    { // file reading TODO: move to its own function maybe.
        std::ifstream infile(fileName);

        // parameters
        infile >> poisSize >> hotelsSize >> tripsSize;
        poisSize -= 2;
        hotelsSize += 2;

        // tour length
        double totalTourLength;
        infile >> totalTourLength;

        // trips length
        try {
            tripsLength = new double [tripsSize];
        } catch(std::bad_alloc) {
            printf("Not enough memory allocated. Exiting...\n");
            return 1;
        }
        double distanceCheck = 0.0;
        for (unsigned int i = 0; i < tripsSize; ++i) {
            infile >> tripsLength[i];
            distanceCheck += tripsLength[i];
        }
        if (distanceCheck >= (totalTourLength * 1.02) ||
            distanceCheck <= (totalTourLength * 0.98)) {
            printf("The given total tour length doesn't correlate with the ");
            printf("length of each individual trip. The instance given is ");
            printf("wrong. Exiting...\n");
            return 1;
        }

        // hotels and points of interest
        try {
            vertices = new struct Vertex [hotelsSize + poisSize];
        } catch(std::bad_alloc) {
            printf("Not enough memory allocated. Exiting...\n");
            return 1;
        }
        for (unsigned int i = 0; i < hotelsSize + poisSize; ++i) {
            vertices[i].index = i;
            infile >> vertices[i].x >> vertices[i].y >> vertices[i].score;
        }
        infile.close();
    }
    if (debug) printf("===========================================\n");
    if (debug) printf("FILE READING OK!\n");
    if (debug == 2) printVariables (tripsSize, tripsLength,
                                    hotelsSize, poisSize, vertices);

// === MATRIX FILLING ==========================================================
    double **distancesMatrix;
    try {
        distancesMatrix = new double *[hotelsSize + poisSize];
        for (unsigned int i = 0; i < hotelsSize + poisSize; ++i)
            distancesMatrix[i] = new double[hotelsSize + poisSize];
    } catch(std::bad_alloc) {
        std::cerr << "Not enough memory allocated.";
        return 1;
    }
    fillMatrix(hotelsSize, poisSize, distancesMatrix);
    if (debug) printf("===========================================\n");
    if (debug) printf("MATRIX FILLING OK!\n");
    if (debug == 3) printMatrix(hotelsSize, poisSize, distancesMatrix);

// === HOTEL SCORE CALCULATION =================================================
    // DONE: picking hotels based on hotel score
    // TODO: picking hotels based on trip score
    calculateHotelScore(hotelsSize, poisSize, vertices, distancesMatrix);
    if (debug) printf("===========================================\n");
    if (debug) printf("HOTEL SCORE CALCULATION OK!\n");
    if (debug == 2) printHotelScores(hotelsSize, vertices);

    struct Trip *bestTour;
    try {
        bestTour = new struct Trip [tripsSize];
    } catch(std::bad_alloc) {
        std::cerr << "Not enough memory allocated.";
        return 1;
    }
    for (unsigned int i = 0; i < tripsSize; ++i)
        bestTour[i].score = 0.0;
    double bestTourTotalScore = 0.0;

// === MAIN LOOP ===============================================================
    for (unsigned int iter = 0; iter < iterNumber; ++iter) {
        struct Trip *tour;
        try {
            tour = new struct Trip [tripsSize];
        } catch(std::bad_alloc) {
            std::cerr << "Not enough memory allocated.";
            return 1;
        }
        for (unsigned int i = 0; i < tripsSize; ++i) {
            tour[i].totalLength = tripsLength[i];
            tour[i].remainingLength = tripsLength[i];
            tour[i].score = 0.0;
        }

// === TOUR HOTEL SELECTION ====================================================
        tourGreedyRandomizedConstruction(
            tripsSize, tour,
            hotelsSize, vertices,
            distancesMatrix,
            HotelRCLSize);
        if (debug && iter == iterNumber - 1) {
            printf("===========================================\n");
            printf("TOUR HOTEL SELECTION OK!\n");
        }
        else if (debug == 2 && iter % 100 == 0) {
            printf("===========================================\n");
            printf("iter %d: TOUR HOTEL SELECTION OK!\n", iter);
            printTourHotels(tripsSize, tour, distancesMatrix);
        }


// === TOUR HOTELS LOCAL SEARCH ================================================
        tourLocalSearch(
            tripsSize, tour,
            hotelsSize, vertices,
            distancesMatrix); // TODO: implement
        // printTourHotels(tripsSize, tour);

// === TOUR POIS SELECTION =====================================================
        // DEBUG: This part of the code produces a Segmentation fault and I
        //          honestly don't know why it happens.
        tripGreedyRandomizedConstruction(
            tripsSize, tour,
            hotelsSize, poisSize, vertices,
            distancesMatrix,
            PoiRCLSize);
        if (debug && iter == iterNumber - 1) {
            printf("===========================================\n");
            printf("TOUR POI SELECTION OK!\n");
        }
        else if (debug == 2 && iter % 100 == 0) {
            printf("===========================================\n");
            printf("iter %d: TOUR POI SELECTION OK!\n", iter);
            printTours(tripsSize, bestTour);
        }

// === TOUR POIS LOCAL SEARCH ==================================================
        // TODO: implement

// === BEST VS CURRENT TOUR COMPARISON =========================================
        double tourTotalScore = 0.0;
        for (unsigned int i = 0; i < tripsSize; ++i)
            tourTotalScore += tour[i].score;
        if (debug == 2 && iter % 100 == 0) {
            printf("===========================================\n");
            printf("current tour score: %.2f\n", tourTotalScore);
            printf("best tour score:    %.2f\n", bestTourTotalScore);
        }
        if (tourTotalScore > bestTourTotalScore) {
            for (unsigned int i = 0; i < tripsSize; ++i)
                bestTour[i] = tour[i];
            bestTourTotalScore = tourTotalScore;
        }
        delete[] tour;
    }
// === OUTPUT FILE WRITING =====================================================
    { // TODO: MAYBE move to it's own function?
        std::string outFile = "out/";
        bool pass = false;
        for (unsigned int i = 0; i < fileName.length(); ++i) {
            if (pass && fileName[i] != '.') outFile += fileName[i];
            else if (fileName[i] == '/') pass = true;
            else if (fileName[i] == '.') pass = false;
            else;
        }
        outFile += ".out";
        writeTours(tripsSize, bestTour, outFile);

        if (debug) printf("===========================================\n");
        if (debug) printf("OUTPUT FILE WRITING OK!\n");
    }
// === MEMORY RELEASING ========================================================
    // TODO: move to it's own function maybe?
    delete[] tripsLength;
    delete[] vertices;
    for (unsigned int i = 0; i < hotelsSize + poisSize; ++i) delete[] distancesMatrix[i];
    delete[] distancesMatrix;
    delete[] bestTour;
    if (debug) printf("===========================================\n");
    if (debug) printf("MEMORY RELEASING OK!\n");
    if (debug) printf("===========================================\n");

    return 0;
}

/*
procedure GRASP(max_iter, seed):
    Read_input(); [1]
    best_solution = null;
    for k = 0,..., max_iter do:
        solution = Greedy_randomized_construction(seed);
        if solution is not feasible then: [2]
            solution = Repair(solution); [3]
        end;
        solution = Local_search(solution);
        Update_solution(solution, best_solution);
    end;
    return(best_solution);
end GRASP;

procedure Greedy_randomized_construction(seed):
    solution = null;
    Initialize the set of candidate elements; [4]
    Evaluate the incremental cost of candidate elements; [5]
    while there exists at least one candidate element do:
        Build the restricted_candidate_list(RCL); [6]
        Select an element s from RCL at random;
        solution = solution + s;
        Update the set of candidate elements;
        Reevaluate the incremental costs;
    end;
    return solution;
end Greedy_randomized_construction;

procedure Local_search(solution): [7]
    while solution is not locally optimal do:
        find solution' in the neighborhood of solution with f(solution') < f(solution);
        solution = solution';
    end;
    return solution;
end Local_search;
*/
